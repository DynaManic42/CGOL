import numpy as np
import pygame as pg

#size = int(input("How big do you want your array to be?: \t"))

Board = np.zeros([30, 30], "int")   #Need to implement scaling for button presses
CBoard = Board.copy()

def adj(x, y, board):
    total = 0
    x_lim = len(Board)
    y_lim = len(Board[0])
    if x > 1 and x < x_lim:
        rows = board[x-2:x+1]
    elif x == 1:
        rows = board[:2]
    elif x == x_lim:
        rows = board[x_lim - 2:]
    for row in rows:
        if y > 1 and y < y_lim:
            low_row = row[y-2:y+1]
        elif y == 1:
            low_row = row[:2]
        elif y == y_lim:
            low_row = row[y_lim - 2:]
        for cell in low_row:
            total += cell
    total -= board[x-1,y-1]
    return total

pg.init()
clock = pg.time.Clock()
window = pg.display.set_mode((300, 300))
running = True
playing = False
cycle = 0

while running:
    clock.tick(100)
    for event in pg.event.get():
        if event.type == pg.QUIT:
            running = False
        elif playing == False and event.type == pg.MOUSEBUTTONUP:
            if event.button == 1:
                row = event.pos[1] // 10
                col = event.pos[0] // 10
                if Board[row][col] == 1:
                    Board[row][col] = 0
                elif Board[row][col] == 0:
                    Board[row][col] = 1
        elif event.type == pg.KEYDOWN:
            if event.key == pg.K_RETURN:
                running = False
                playing = True
            
    window.fill(0)
    for iy, rowOfCells in enumerate(Board):
        for ix, cell in enumerate(rowOfCells):
            color = (64, 64, 64) if cell ==  1 else (164, 164, 164)
            pg.draw.rect(window, color, (ix*10+1, iy*10+1, 9, 9))
    pg.display.flip()

while playing:  
    for event in pg.event.get():
        if event.type == pg.QUIT:
            playing = False
    #Find next pattern
    is_dead = True
    for x in range(1, len(Board) + 1):
        for y in range(1, len(Board[0]) + 1):
            if Board[x-1, y-1] == 1:
                is_dead = False
            if adj(x, y, Board) <= 1 or adj(x, y, Board) >= 4:
                CBoard[x-1][y-1] = 0
            elif adj(x, y, Board) == 2:
                CBoard[x-1][y-1] = Board[x-1][y-1]
            elif adj(x, y, Board) == 3:
                CBoard[x-1][y-1] = 1
    
    window.fill(0)
    for iy, rowOfCells in enumerate(Board):
        for ix, cell in enumerate(rowOfCells):
            color = (64, 64, 64) if cell ==  1 else (164, 164, 164)
            pg.draw.rect(window, color, (ix*10+1, iy*10+1, 9, 9))
    pg.display.flip()
    
    if is_dead:
        print(f"All life ended, lasted {cycle} cycle(s)")
        playing = 
    
    np.copyto(Board, CBoard)
    clock.tick(4)

pg.quit()
#ToDo: Enable zoom-in and zoom-out
