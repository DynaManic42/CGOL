import numpy as np
import pygame as pg

size = int(input("How big do you want your array to be?: \t"))

Board = np.zeros([size, size], "int")
CBoard = Board.copy()

def adj(x, y, board):
    total = 0
    x_lim = len(Board)
    y_lim = len(Board[0])
    if x > 1 and x < x_lim:
        rows = board[x-2:x+1]
    elif x == 1:
        rows = board[:2]
    elif x == x_lim:
        rows = board[x_lim - 2:]
    for row in rows:
        if y > 1 and y < y_lim:
            low_row = row[y-2:y+1]
        elif y == 1:
            low_row = row[:2]
        elif y == y_lim:
            low_row = row[y_lim - 2:]
        for cell in low_row:
            total += cell
    total -= board[x-1,y-1]
    return total

pg.init()
clock = pg.time.Clock()
screen = pg.display.set_mode((int(size*50), int(size*50)))
running = True

while running:
    
    for event in pg.event.get():
        if event.type == pg.QUIT:
            running = False
        elif event.type == pg.MOUSEBUTTONUP:
            x,y = event.pos
    #Find next pattern
    for x in range(1, len(Board) + 1):
        for y in range(1, len(Board[0]) + 1):
            if adj(x, y, Board) <= 1 or adj(x, y, Board) >= 4:
                CBoard[x-1][y-1] = 0
            elif adj(x, y, Board) == 2:
                CBoard[x-1][y-1] = Board[x-1][y-1]
            elif adj(x, y, Board) == 3:
                CBoard[x-1][y-1] = 1
    
    print(Board, "\n")
    #pygame_img = pg.image.frombuffer(Board.tostring(), Board.shape[1::-1], "RGB")
    #screen.blit(pg, (0, 0))
    #pg.display.update()
    np.copyto(Board, CBoard)
    clock.tick(1)


#ToDo: Enable dynamic matrix input, create easy method of displaying matrix as pixels (grid)
